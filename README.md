# gvv
 Factorio global Variable Viewer mod.  
 
### Download  
https://mods.factorio.com/mod/gvv
 
### Github
https://github.com/x2605/gvv
 
### How to use  
- Type **/gvv** or press **CTRL+SHIFT+V** (you can change key bindings) to open GUI. Only admins can use the mod if it is multiplay game.  
To allow **gvv** to access **global** table of mod, savefile or scenario(start from beginning), you need to modify "**control.lua**" file of demand mod or map.  
Input following code at first line or last line of "**control.lua**" file of the mod or map.
``` lua
remote.add_interface("__"..script.mod_name.."__gvv",{global=function() return global end, diag=function() local rm,po,mt,c,e,p,l,j,it={},{},{},0,0,0,0,0 local du=function(b,m) local n={} for i,v in ipairs(b) do n[#n+1]=v end n[#n+1]=m return n end local va=function(v) local s,a=pcall(function()return v.valid end) if s then return a else return end end local u={LuaGameScript=true,LuaBootstrap=true,LuaRemote=true,LuaCommandProcessor=true,LuaSettings=true,LuaRCON=true,LuaRendering=true} it=function(b,pth,o) local t for k,v in pairs(b) do t=type(k) y=type(v) if t=='function' or t=='userdata' or t=='thread' or y=='function' or y=='userdata' or y=='thread' then if o then return true else j=j+1 rm[#rm+1]=du(pth,t..j) e=e+1 end elseif t=='nil' then if o then if y=='table' and getmetatable(v)=='private' and v.object_name then if u[v.object_name] then return true else return false end elseif y=='table' then return it(v,nil,true) end else j=j+1 rm[#rm+1]=du(pth,t..j) e=e+1 end elseif t=='table' and getmetatable(k)=='private' and k.object_name then if o then if u[k.object_name] then return true end else if va(k) and not u[k.object_name] then if y=='table' and getmetatable(v)=='private' and v.object_name then if u[v.object_name] then j=j+1 rm[#rm+1]=du(pth,k.object_name..j) e=e+1 else j=j+1 po[#po+1]=du(pth,k.object_name..j) p=p+1 end elseif y=='table' and getmetatable(v) then j=j+1 po[#po+1]=du(pth,k.object_name..j) p=p+1 mt[#mt+1]=du(pth,k.object_name..j) l=l+1 it(v,du(pth,k.object_name..j)) elseif y=='table' then j=j+1 po[#po+1]=du(pth,k.object_name..j) p=p+1 it(v,du(pth,k.object_name..j)) else j=j+1 po[#po+1]=du(pth,k.object_name..j) p=p+1 end elseif u[k.object_name] then j=j+1 rm[#rm+1]=du(pth,k.object_name..j) e=e+1 else j=j+1 rm[#rm+1]=du(pth,k.object_name..j) e=e+1 end end elseif t=='table' then if o then return it(k,nil,true) else if it(k,nil,true) then j=j+1 rm[#rm+1]=du(pth,t..j) e=e+1 else if y=='table' and getmetatable(v)=='private' and v.object_name then if u[v.object_name] then j=j+1 rm[#rm+1]=du(pth,t..j) e=e+1 else j=j+1 po[#po+1]=du(pth,t..j) p=p+1 end elseif y=='table' and getmetatable(v) then j=j+1 po[#po+1]=du(pth,t..j) p=p+1 mt[#mt+1]=du(pth,t..j) l=l+1 it(v,du(pth,t..j)) elseif y=='table' then j=j+1 po[#po+1]=du(pth,t..j) p=p+1 it(v,du(pth,t..j)) else j=j+1 po[#po+1]=du(pth,t..j) p=p+1 end end end elseif y=='table' and getmetatable(v)=='private' and v.object_name then if u[v.object_name] then if o then return true else rm[#rm+1]=du(pth,k) e=e+1 end elseif o then else c=c+1 end elseif y=='table' then if o then return it(v,nil,true) elseif getmetatable(v) then mt[#mt+1]=du(pth,k) l=l+1 it(v,du(pth,k)) else it(v,du(pth,k)) c=c+1 end elseif o then else c=c+1 end end end it(global,{}) return {trouble=rm,meta=mt,m_count=l,n_count=c,e_count=e,potential=po,p_count=p} end, fix=function() local rm,po,mt,c,e,p,l,j,it={},{},{},0,0,0,0,0 local du=function(b,m) local n={} for i,v in ipairs(b) do n[#n+1]=v end n[#n+1]=m return n end local va=function(v) local s,a=pcall(function()return v.valid end) if s then return a else return end end local u={LuaGameScript=true,LuaBootstrap=true,LuaRemote=true,LuaCommandProcessor=true,LuaSettings=true,LuaRCON=true,LuaRendering=true} it=function(b,pth,o) local t for k,v in pairs(b) do t=type(k) y=type(v) if t=='function' or t=='userdata' or t=='thread' or y=='function' or y=='userdata' or y=='thread' then if o then return true else j=j+1 rm[#rm+1]=du(pth,t..j) b[k]=nil e=e+1 end elseif t=='nil' then if o then if y=='table' and getmetatable(v)=='private' and v.object_name then if u[v.object_name] then return true else return false end elseif y=='table' then return it(v,nil,true) end else j=j+1 rm[#rm+1]=du(pth,t..j) b[k]=nil e=e+1 end elseif t=='table' and getmetatable(k)=='private' and k.object_name then if o then if u[k.object_name] then return true end else if va(k) and not u[k.object_name] then if y=='table' and getmetatable(v)=='private' and v.object_name then if u[v.object_name] then j=j+1 rm[#rm+1]=du(pth,k.object_name..j) b[k]=nil e=e+1 else j=j+1 po[#po+1]=du(pth,k.object_name..j) p=p+1 end elseif y=='table' and getmetatable(v) then j=j+1 po[#po+1]=du(pth,k.object_name..j) p=p+1 mt[#mt+1]=du(pth,k.object_name..j) l=l+1 it(v,du(pth,k.object_name..j)) elseif y=='table' then j=j+1 po[#po+1]=du(pth,k.object_name..j) p=p+1 it(v,du(pth,k.object_name..j)) else j=j+1 po[#po+1]=du(pth,k.object_name..j) p=p+1 end elseif u[k.object_name] then j=j+1 rm[#rm+1]=du(pth,k.object_name..j) b[k]=nil e=e+1 else j=j+1 rm[#rm+1]=du(pth,k.object_name..j) b[k]=nil e=e+1 end end elseif t=='table' then if o then return it(k,nil,true) else if it(k,nil,true) then j=j+1 rm[#rm+1]=du(pth,t..j) b[k]=nil e=e+1 else if y=='table' and getmetatable(v)=='private' and v.object_name then if u[v.object_name] then j=j+1 rm[#rm+1]=du(pth,t..j) b[k]=nil e=e+1 else j=j+1 po[#po+1]=du(pth,t..j) p=p+1 end elseif y=='table' and getmetatable(v) then j=j+1 po[#po+1]=du(pth,t..j) p=p+1 mt[#mt+1]=du(pth,t..j) l=l+1 it(v,du(pth,t..j)) elseif y=='table' then j=j+1 po[#po+1]=du(pth,t..j) p=p+1 it(v,du(pth,t..j)) else j=j+1 po[#po+1]=du(pth,t..j) p=p+1 end end end elseif y=='table' and getmetatable(v)=='private' and v.object_name then if u[v.object_name] then if o then return true else rm[#rm+1]=du(pth,k) b[k]=nil e=e+1 end elseif o then else c=c+1 end elseif y=='table' then if o then return it(v,nil,true) elseif getmetatable(v) then mt[#mt+1]=du(pth,k) l=l+1 it(v,du(pth,k)) else it(v,du(pth,k)) c=c+1 end elseif o then else c=c+1 end end end it(global,{}) return {trouble=rm,meta=mt,m_count=l,n_count=c,e_count=e,potential=po,p_count=p} end, })
```
- In case of savefile, extract "**control.lua**" from it first. Then, edit code and overwrite it at same location of "**control.lua**" inside of the zipped file.  
- Most of other helpful words are inside of **Helper** tab in **gvv** in-game GUI.  

### 사용 방법
- 모드, 세이브파일, 또는 시나리오(처음부터 시작)의 **global** 테이블에 **gvv**가 액세스할 수 있게 하려면 해당 지도 또는 모드의 "**control.lua**" 파일을 변경해야 합니다.
- 지도 또는 모드의 "**control.lua**" 파일의 첫 줄 또는 마지막 줄에 다음의 코드를 삽입하세요.
``` lua
remote.add_interface("__"..script.mod_name.."__gvv",{global=function() return global end})
```
- 세이브파일의 경우에는 압축파일에서 "**control.lua**"만 꺼낸 뒤, 편집하고 압축파일 내부의 같은 위치에 "**control.lua**"를 덮어쓰세요.
- 다른 도움말은 게임 내 **gvv** GUI의 **도움 기능** 탭에서 확인할 수 있습니다.

### Commands added by this mod  
- **/gvv** : Opens/closes gvv main GUI window. Only admins or player in singleplay can use this command.  
- **/gmods** : Prints loaded mod list and global accessible mod list.  
- **/gdump** : Same as /gdump-luaon  
- **/gdump-luaon** <mod_name>(optional) : Prints global data of accessible mod in lua object notation format.  
  If no <mod_name> is given, level(current map) will be used.  
- **/gdump-json** <mod_name>(optional) : Prints global data of accessible mod in js object notation format.  
  If no <mod_name> is given, level(current map) will be used.  
